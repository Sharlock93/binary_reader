
move

mem
reg


mem => scale + index + base + disp32


if mem+sib
	modrm => jk




mov
left - stack, register, memory
right - satck, register, memory

 				stack 							reg 		mem		imm?
 left

 stack  	


 reg		


 mem		


 imm?










ops reduction: 

add  (no three op, result)
 left op
 right op

 always result = left + right

 left = left + right


(immediate? cannot be immediate, but we load all immediates into register?) 
maybe this is wrong, save one move for immediate value? 


- should add op be responsible for the store back to location?
	currently it is

left - stack, register, memory
right - satck, register, memory

 				stack 							reg 		mem		imm?
 left
 stack  	mov left to reg first	  	 
 			add from stack
			(mov reg, stack)
			( add reg, stack )


 reg		add stack to reg


 mem		mov mem to reg


 imm?



 both stack and mem are just mem movs, difference is SIB and ModRM

 mov reg, mem, stack - diff only in ModRM and SIB? 
 	- if we choose mov for left op be 



i32 foo = 1;
mov foo, 1

foo = foo + 2 => add foo, 2


i32 foo = (1 + 5*2) + 2;

could be this: 
mov foo, 1
add foo, 2

compared to  this

mov reg, foo
add reg, 2
mov foo, reg

--

i32 foo = (1 + 5*2) + 2;


this 
mov foo, 1
mov reg, 5
mul reg, 2
add foo, reg
add foo, 2

compared to


mov reg1, 1
mov reg2, 5
mul reg2, 2
add reg1, reg2
mov reg2, 2
add reg1, reg2
mov foo, reg1

--

i32 foo = 5;

foo = foo*foo + foo;

mov reg, foo
mul reg, reg
add reg, foo
mov foo, reg


// can we recursively know that a value of the stack has been loaded into a register?


============================================================



tomorrow todo: 
-- calls with params -> stack
	- store some vars (rcx, rdx, r8, r9)
-- local variables -> assigned on stack





if cond = cmp 5, 2
cmp eax, 1?
jneq
{
	next_label <- // jump next if or else? 
	..do if .. body
	..jmp end...
} // next label pos = size of generated body? 

next_lbl: elif: ( 1 > 2 )

jneq
{
	next_label <- // jump next if or else? 
	..do if .. body
	..jmp end...
}

next_lbl: else:
..else body..

end  --  end of stmt
.....




===============================================================
x64 calling convention


- RAX, RCX, RDX, R8, R9,  R10,  R10 => can be overwritten, no need to save ? 
	- calle should not worry about these
	- caller should -> save restore 


- RBX, RBP, RSP, RDI, RSI, R12-15 => must be saved in the func called later restored? 





// /

RAX <= RAX

save value push RAX

1 + func();




[ RAX ]




 1  + 2
 12+

 push 1
 push 2 
 push +

 pop +
 	val = 1 + 2
 push val

 1

 left => mov RAX <=1 
 push RAX
 right <= mov RAX <= 2 

 RAX < 2

 ADD RAX + 1

 add RAX, RAX => 4

 pop RAX 
 

==========================================

type -> defined_type 


struct -> type -> decls -> var_decls -> types too

struct can be a type

fields

	var decls; *

typedef that creates an alias


decl | type -> type name

aliases another type



typedef void (*func_type)(void);

func_type *ptr = { func1, func2, func3 };

+ 
	1
	ptr

		func_type* 

		return type is func_type*

* 
	ptr
	return func_type base

(*ptr)();




============================================================

todo

- arrary index && array init/compound literals done
	- array init/literal - done
	i32[] meow = [1, 2, 3, 4] <> { 1, 2, 3, 4}

	mewo[0] = 32;

- field access -> or . => done

	struct x {
		i32 meow;
	}

	x t = { 2 } // comp_lit

	t.meow = 4;

	x *some = &t;
	some->meow = 5; 


- address of operator - done
	i32 some_var = 2;
	i32 *ptr = nil;
	ptr = &some_var;

- ptr deref - done
	i32 i = *ptr;



- switch cases
	switch(condi) { switch_body }


- else & else if:
	parse and type check

============================================================


code: 



setting up static data must be done before jumpping into the code

so before code run: 
- mv str "hello world" to data_section
	- maybe cpy to mem? 


setup stack ptr


===========================================================

4 bytes for i; on the stack? 
4 bytes for x
4 bytes for y;

first temp mem: 

write 1 to data <- addr on decl i
write 2 to data <- addr on decl x

mov i -> rax
mov x -> rbx 
add rax, rbx
mov rax -> @y_mem

write 



=========================================================
==========================================================


Code Gen Setup: 
	- move RSP => RAX
	- MOVE RBP => RCX
	- SET RBP & RSP to your own memory locations
	- PUSH RAX, RCX => save stack ptr and base

	- END Of "main" func => 
		- pop stack top => RSP, RBP restore the stack




go through decls => 
	if id == main => assign main_memory to rand_func
	jump

- jump into "main_function"


generating functions: 
	- they are just memory addresses to jump to
		- every function must save some registers and restore them if used
	


