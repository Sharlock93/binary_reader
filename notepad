x64 calling convention


- RAX, RCX, RDX, R8, R9,  R10,  R10 => can be overwritten, no need to save ? 
	- calle should not worry about these
	- caller should -> save restore 


- RBX, RBP, RSP, RDI, RSI, R12-15 => must be saved in the func called later restored? 





// /

RAX <= RAX

save value push RAX

1 + func();




[ RAX ]




 1  + 2
 12+

 push 1
 push 2 
 push +

 pop +
 	val = 1 + 2
 push val

 1

 left => mov RAX <=1 
 push RAX
 right <= mov RAX <= 2 

 RAX < 2

 ADD RAX + 1

 add RAX, RAX => 4

 pop RAX 
 

==========================================

type -> defined_type 


struct -> type -> decls -> var_decls -> types too

struct can be a type

fields

	var decls; *

typedef that creates an alias


decl | type -> type name

aliases another type



typedef void (*func_type)(void);

func_type *ptr = { func1, func2, func3 };

+ 
	1
	ptr

		func_type* 

		return type is func_type*

* 
	ptr
	return func_type base

(*ptr)();




============================================================

todo

- arrary index && array init/compound literals done
	- array init/literal - done
	i32[] meow = [1, 2, 3, 4] <> { 1, 2, 3, 4}

	mewo[0] = 32;

- field access -> or . => done

	struct x {
		i32 meow;
	}

	x t = { 2 } // comp_lit

	t.meow = 4;

	x *some = &t;
	some->meow = 5; 


- address of operator - done
	i32 some_var = 2;
	i32 *ptr = nil;
	ptr = &some_var;

- ptr deref - done
	i32 i = *ptr;



- switch cases
	switch(condi) { switch_body }


- else & else if:
	parse and type check

============================================================


code: 



setting up static data must be done before jumpping into the code

so before code run: 
- mv str "hello world" to data_section
	- maybe cpy to mem? 


setup stack ptr


===========================================================

4 bytes for i; on the stack? 
4 bytes for x
4 bytes for y;

first temp mem: 

write 1 to data <- addr on decl i
write 2 to data <- addr on decl x

mov i -> rax
mov x -> rbx 
add rax, rbx
mov rax -> @y_mem

write 



=========================================================
==========================================================


Code Gen Setup: 
	- move RSP => RAX
	- MOVE RBP => RCX
	- SET RBP & RSP to your own memory locations
	- PUSH RAX, RCX => save stack ptr and base

	- END Of "main" func => 
		- pop stack top => RSP, RBP restore the stack




go through decls => 
	if id == main => assign main_memory to rand_func
	jump

- jump into "main_function"


generating functions: 
	- they are just memory addresses to jump to
		- every function must save some registers and restore them if used
	


